// =====================================================
// AVATAR ENGINE v3.0 - L√≥gica Limpa
// =====================================================
// SEM aleatoriedade. SEM timers autom√°ticos.
// Express√£o muda APENAS quando:
// 1. EmotionEngine processa uma mensagem
// 2. Usu√°rio clica em bot√£o de teste
// 3. Lip-sync durante √°udio
// =====================================================

import FrameMap from './FrameMap.json'

// =====================================================
// TIPOS
// =====================================================

export type ExpressionName =
    | 'neutral' | 'happy' | 'surprised' | 'confused'
    | 'curious' | 'sad' | 'frustrated' | 'proud'
    | 'bored' | 'contempt' | 'fearful' | 'envious' | 'focused'

export type TalkState = 'closed' | 'mid' | 'open'

export interface AvatarState {
    expression: ExpressionName  // Emo√ß√£o atual
    isTalking: boolean          // Se est√° em lip-sync
    talkState: TalkState        // Estado da boca durante fala
    emotionTemperature: number  // 1-10
}

export interface AvatarFrame {
    url: string         // URL da imagem atual
    transition: number  // Dura√ß√£o do crossfade em ms
}

type Listener = (state: AvatarState, frame: AvatarFrame) => void

// =====================================================
// CONFIGURA√á√ÉO
// =====================================================

const CONFIG = {
    expressionTransition: 200,   // ms para trocar express√£o
    talkTransition: 80,          // ms para trocar frame de fala
    talkCycleInterval: 150       // ms entre frames de fala
}

// =====================================================
// CLASSE PRINCIPAL
// =====================================================

class AvatarEngineClass {
    // Estado interno
    private _expression: ExpressionName = 'neutral'
    private _isTalking: boolean = false
    private _talkState: TalkState = 'closed'
    private _temperature: number = 5

    // Timer de lip-sync
    private _talkTimer: ReturnType<typeof setInterval> | null = null
    private _talkPhase: number = 0

    // Listeners
    private _listeners: Set<Listener> = new Set()

    constructor() {
        console.log('üé≠ AvatarEngine v3.0 inicializado (L√≥gica Limpa)')
    }

    // =====================================================
    // GETTERS
    // =====================================================

    get state(): AvatarState {
        return {
            expression: this._expression,
            isTalking: this._isTalking,
            talkState: this._talkState,
            emotionTemperature: this._temperature
        }
    }

    get frame(): AvatarFrame {
        // Se est√° falando, usa frame de fala
        // Sen√£o, usa frame da emo√ß√£o
        if (this._isTalking) {
            const talkData = (FrameMap.talk as Record<TalkState, { file: string }>)[this._talkState]
            return {
                url: talkData?.file || this.getExpressionUrl(this._expression),
                transition: CONFIG.talkTransition
            }
        }

        return {
            url: this.getExpressionUrl(this._expression),
            transition: CONFIG.expressionTransition
        }
    }

    get expressions(): ExpressionName[] {
        return Object.keys(FrameMap.expressions) as ExpressionName[]
    }

    // =====================================================
    // OBTER URL DA EXPRESS√ÉO
    // =====================================================

    private getExpressionUrl(expr: ExpressionName): string {
        const data = (FrameMap.expressions as Record<string, { file: string }>)[expr]
        return data?.file || (FrameMap.expressions as any).neutral.file
    }

    // =====================================================
    // DEFINIR EXPRESS√ÉO (chamado pelo EmotionEngine)
    // =====================================================

    setExpression(expression: ExpressionName) {
        // N√£o muda se estiver falando (lip-sync tem prioridade)
        if (this._isTalking) {
            // Salvar para usar depois que parar de falar
            this._expression = expression
            console.log(`üé≠ Express√£o agendada: ${expression} (ap√≥s lip-sync)`)
            return
        }

        if (this._expression === expression) return

        this._expression = expression
        console.log(`üé≠ Express√£o: ${expression}`)
        this.notify()
    }

    // =====================================================
    // TEMPERATURA EMOCIONAL
    // =====================================================

    setEmotionTemperature(temp: number) {
        this._temperature = Math.max(1, Math.min(10, temp))
        console.log(`üå°Ô∏è Temperatura: ${this._temperature}`)
        this.notify()
    }

    getExpressionsForTemperature(): ExpressionName[] {
        const key = String(this._temperature)
        const mapping = FrameMap.temperatureMapping as Record<string, string[]>
        return (mapping[key] || mapping['5']) as ExpressionName[]
    }

    // =====================================================
    // LIP-SYNC (separado da emo√ß√£o)
    // =====================================================

    startTalking() {
        if (this._isTalking) return

        this._isTalking = true
        this._talkPhase = 0

        console.log('üó£Ô∏è Lip-sync iniciado')

        // Ciclo: closed ‚Üí mid ‚Üí open ‚Üí mid ‚Üí closed ...
        const talkSequence: TalkState[] = ['closed', 'mid', 'open', 'mid']
        let index = 0

        this._talkTimer = setInterval(() => {
            this._talkState = talkSequence[index]
            index = (index + 1) % talkSequence.length
            this.notify()
        }, CONFIG.talkCycleInterval)

        // Notificar estado inicial
        this._talkState = 'closed'
        this.notify()
    }

    stopTalking() {
        if (!this._isTalking) return

        if (this._talkTimer) {
            clearInterval(this._talkTimer)
            this._talkTimer = null
        }

        this._isTalking = false
        this._talkState = 'closed'

        console.log(`üó£Ô∏è Lip-sync parado. Voltando para: ${this._expression}`)

        // Volta para a express√£o atual
        this.notify()
    }

    // =====================================================
    // EVENTOS DO SISTEMA
    // =====================================================

    onSpeakingStart() {
        this.startTalking()
    }

    onSpeakingEnd() {
        this.stopTalking()
    }

    onListeningStart() {
        this.setExpression('curious')
    }

    onThinking() {
        this.setExpression('focused')
    }

    onIdle() {
        // N√£o muda automaticamente - s√≥ quando EmotionEngine decidir
    }

    // =====================================================
    // APLICAR EMO√á√ÉO DO GPT (chamado pelo EmotionEngine)
    // =====================================================

    applyEmotion(emotion: ExpressionName) {
        // Verificar se √© permitida pela temperatura
        const allowed = this.getExpressionsForTemperature()
        const finalEmotion = allowed.includes(emotion) ? emotion : (allowed[0] || 'neutral')

        this.setExpression(finalEmotion)
    }

    // =====================================================
    // LISTENERS
    // =====================================================

    subscribe(listener: Listener): () => void {
        this._listeners.add(listener)
        listener(this.state, this.frame)
        return () => this._listeners.delete(listener)
    }

    private notify() {
        const state = this.state
        const frame = this.frame
        this._listeners.forEach(l => l(state, frame))
    }

    // =====================================================
    // CLEANUP
    // =====================================================

    destroy() {
        if (this._talkTimer) clearInterval(this._talkTimer)
        this._listeners.clear()
    }
}

// =====================================================
// SINGLETON
// =====================================================

export const AvatarEngine = new AvatarEngineClass()
export default AvatarEngine
